1ï¸âƒ£ JVM (Java Virtual Machine)
JVM is not a compiler.

It is a runtime engine that executes Java bytecode.

JVM makes Java platform-independent (Write Once, Run Anywhere).

Responsibilities:

Loads bytecode (.class)

Verifies bytecode

Executes it (using Interpreter + JIT)

Manages memory (Heap, Stack, GC)

ğŸ‘‰ Different OS â†’ different JVM â†’ same bytecode

2ï¸âƒ£ Java Compiler (javac)
Converts Java source code (.java) â†’ Bytecode (.class)

Happens before execution

Does not understand OS or hardware

Command:

javac Test.java   // creates Test.class
3ï¸âƒ£ Bytecode
Intermediate code generated by compiler

Stored in .class files

Not machine code

Executed by JVM, not by CPU directly

ğŸ‘‰ This is why Java is portable.

public static void main(String[] args) â€” fully explained
4ï¸âƒ£ public
JVM must access this method from outside the class

If not public â†’ program wonâ€™t start

5ï¸âƒ£ static
JVM calls main() without creating an object

Static belongs to the class, not instance

âŒ If non-static â†’ JVM canâ€™t call it

6ï¸âƒ£ void
main() does not return anything

JVM doesnâ€™t expect a return value

7ï¸âƒ£ main
Predefined entry point

JVM always starts execution from main

8ï¸âƒ£ String[] args
Used to accept command-line arguments

args is just a variable name (can be anything)

String[] is mandatory

Example:

java Test hello 10
Code:

public static void main(String[] args) {
    System.out.println(args[0]); // hello
    System.out.println(args[1]); // 10
}
Execution Flow (very important)
.java file
   â†“ (javac)
.class (bytecode)
   â†“ (JVM)
OS-specific machine code
   â†“
Output